// --------------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// --------------------------------------------------------------------------------------------
using System;
using System.IO;
using McMaster.Extensions.CommandLineUtils;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Microsoft.Oryx.BuildScriptGenerator;
using Microsoft.Oryx.BuildScriptGenerator.Exceptions;
using Microsoft.Oryx.Common.Utilities;

namespace Microsoft.Oryx.BuildScriptGeneratorCli
{
    internal partial class Program
    {
        public int OnExecute(CommandLineApplication app, IConsole console)
        {
            if (string.IsNullOrEmpty(SourceCodeFolder))
            {
                app.ShowHelp();
                return 1;
            }

            var serviceProvider = new ServiceProviderBuilder()
                    .WithScriptGenerationOptions(this)
                    .Build();

            var logger = serviceProvider.GetRequiredService<ILogger<Program>>();

            try
            {
                var options = serviceProvider.GetRequiredService<IOptions<BuildScriptGeneratorOptions>>().Value;

                if (!IsValidInput(options, console))
                {
                    return 1;
                }

                var scriptGeneratorProvider = serviceProvider.GetRequiredService<IScriptGeneratorProvider>();
                var sourceRepoProvider = serviceProvider.GetRequiredService<ISourceRepoProvider>();

                // Create a root temp directory for this tool under which all temporary files
                // generated by different services can be placed under.
                EnsureTempDirectory(options);

                var sourceRepo = sourceRepoProvider.GetSourceRepo();
                var scriptGeneratorContext = new ScriptGeneratorContext
                {
                    SourceRepo = sourceRepo,
                    LanguageName = options.LanguageName,
                    LanguageVersion = options.LanguageVersion,
                    OutputFolder = options.OutputFolder,
                    TempDirectory = options.TempDirectory,
                    GenerateScriptOnly = options.ScriptOnly,
                };

                // Get script generator
                var scriptGenerator = scriptGeneratorProvider.GetScriptGenerator(scriptGeneratorContext);
                if (scriptGenerator == null)
                {
                    console.WriteLine(
                        "Error: Could not find a script generator which can generate a script for " +
                        $"the code in '{options.SourceCodeFolder}'.");
                    return 1;
                }

                // Get the path where the generated script should be written into.
                var scriptPath = GetScriptPath(options);

                // Write the content to the script.
                var scriptContent = scriptGenerator.GenerateBashScript(scriptGeneratorContext);
                File.WriteAllText(scriptPath, scriptContent);
                console.WriteLine($"Script was generated successfully at '{scriptPath}'.");

                // Set execute permission on the generated script.
                (var exitCode, var output) = ProcessHelper.RunProcessAndCaptureOutput(
                    "chmod",
                    arguments: new[] { "+x", scriptPath });
                if (exitCode != 0)
                {
                    console.WriteLine(
                        $"Error: Could not set execute permission on the generated script '{scriptPath}'." +
                        Environment.NewLine +
                        $"Output: {output}");
                    return 1;
                }

                if (options.ScriptOnly)
                {
                    return 0;
                }

                // Run the generated script
                console.WriteLine();
                console.WriteLine($"Running the script '{scriptPath}' ...");
                (exitCode, output) = ProcessHelper.RunProcessAndCaptureOutput(
                    scriptPath,
                    arguments: new[]
                    {
                        sourceRepo.RootPath,
                        options.OutputFolder
                    },
                    waitForExitInSeconds: (int)TimeSpan.FromMinutes(10).TotalSeconds);
                console.WriteLine();
                console.WriteLine(output);

                return exitCode;
            }
            catch (InvalidUsageException ex)
            {
                console.WriteLine(ex.Message);
                return 1;
            }
            catch (Exception ex)
            {
                logger.LogError($"An error occurred while running this tool:" + Environment.NewLine + ex.ToString());
                console.WriteLine("Oops... An unexpected error has occurred.");
                return 1;
            }
            finally
            {
                // In general it is a good practice to dispose services before this program is
                // exiting, but there's one more reason we would need to do this i.e that the Console
                // logger doesn't write to the console immediately. This is because it runs on a separate
                // thread where it queues up messages and writes the console when the queue reaches a certain
                // threshold.
                if (serviceProvider is IDisposable disposable)
                {
                    disposable.Dispose();
                }
            }
        }

        private static void EnsureTempDirectory(BuildScriptGeneratorOptions options)
        {
            if (string.IsNullOrEmpty(options.TempDirectory))
            {
                throw new InvalidOperationException(
                    $"'{nameof(BuildScriptGeneratorOptions.TempDirectory)}' cannot be null or empty.");
            }

            Directory.CreateDirectory(options.TempDirectory);
        }

        private static string GetScriptPath(BuildScriptGeneratorOptions options)
        {
            var scriptPath = options.ScriptPath;
            if (string.IsNullOrEmpty(scriptPath))
            {
                scriptPath = Path.Combine(options.TempDirectory, "build.sh");
            }
            else
            {
                scriptPath = Path.GetFullPath(scriptPath);
            }

            return scriptPath;
        }

        // To enable unit testing
        internal bool IsValidInput(BuildScriptGeneratorOptions options, IConsole console)
        {
            if (!Directory.Exists(options.SourceCodeFolder))
            {
                console.WriteLine($"Error: Could not find the source code folder '{options.SourceCodeFolder}'.");
                return false;
            }

            if (!options.ScriptOnly && string.IsNullOrEmpty(options.OutputFolder))
            {
                console.WriteLine("Error: Either script only or output folder must be provided.");
                return false;
            }

            if (options.ScriptOnly)
            {
                if (string.IsNullOrEmpty(options.ScriptPath))
                {
                    console.WriteLine("Error: Script path is required to be supplied if script only option is chosen.");
                    return false;
                }
                else
                {
                    return true;
                }
            }
            return true;
        }
    }
}
